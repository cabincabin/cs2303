README File for PA3_cjdembski_fjvanrossum CS2303 Assignment
Authors: Clayton Dembski & Floris van Rossum
Created: 9/17/17
Last Updated: 9/21/17 2:30 pm

Included Files:
PA3_cjdembski_fjvanrossum.c
readWords.c
readWords.h
tree.c
tree.h
README.txt

How to use:
The PA3_cjdembsi_fjvanrossum program compiles by typing "make" or "make all" in 
the command line when in the correct directory. This will cause object files to be
generated by the makefile. tree.o, readWords.o will be generated. The program can
be run by entering ./PA output input1 input2 ... where output is the name of the output
file and input are the input files. Recommended file type for input is .txt. Entering
this command will start the program, read the files as defined by the user, and print
all the words and their respective counts. The program also creates a file according
to a user specified name. 

Doxygen: 
In order to generate the necessary doxygen files with our doxygen configuration file called PA3_cjdembski_fjvanrossum. Type "doxygen PA3_cjdembski_fjvanrossum" in your command line, this will
generate all the necessary files in order to have a doxygen documentation page. Click on index.html in order to open the page.

Purpose:
This program counts all the words in the user-specified file and then prints out those
words and their count as well as generating an output file with the output of the program.

Program Structure:
As requested in the assignment the program contains at least two header and source files.
This was accomplished as we divided up the code for the tree as well as the code for the 
file reading and writing. PA3_cjdembsi_fjvanrossum houses the main code that starts 
the program, handles user input and calls the necessary functions.

tree.c:
Contains all the necessary functions to handle the binary tree data structure. 
There are functions to create nodes, insert a word and list all nodes. This file
defines the struct which all nodes follow. This source file has a header file
tree.h which has all the functions necessary in order to handle the binary
tree.

readWords.c
Houses the functions necessary to open the user specified text file, read
the correct words from it, return those words and then close the file 
properly. readWords.c has a header file readWords.h which allows 
PA3_cjdembsi_fjvanrossum to use all the necessary functions in order
to read a file's words.

PA3_cjdembsi_fjvanrossum.c:
Holds main(), the start of the program. The main() method contains the
loop necessary in order read multiple different files and print all the 
words in alphabetic order in the end. This source file contains a few
functions that allow it to read multiple user specified files.

Brief Program Flow:
1. main() is run, this initializes the first file, gets the first word
stores it in the root node of our binary tree. 
2. A while loop starts that will read all the following words in the first file 
and store them in the binary tree. Once it is done the file will close. 
3. If the user has input more than one file in the command line, those files will
 be opened, read and stored in the binary tree one by one as well.
4. When all files have been read and stored all words, the count of each word is 
printed out as well as the number of unique words and the total number of words.

Detailed Program Flow:

Loop-invariants:

PA3_cjdembsi_fjvanrossum.c:
	
	int main(int argc, char ** argv)
		//Pre-condition: File is opened correctly, word is not -1
		while (word[0] != -1)
		//Loop-Invariant: word is not -1 in the while loop
		//Loop-Invariant: Word has been inserted into the binary tree
			Pre-condition: word[100] is initialized
			for(int i = 0; i<100; i++)
			//Loop-Invariant: word[i] is now 'a'
		//Pre-condition: Command-line arguments are entered, more than 1 argument
		//is entered
		for(int i = 1; i < argc - 1; i++)
			//Loop-invariant: i is less than the number of commands entered by user
			//prints the current file that is entered in the node
	
	void readFile(char * fileName, char * word, struct node * rootNode)
		//Pre-condition: word[0] should not be -1, and the file is correctly setup
		while (word[0] != -1)
			//Loop-invariant: string word is inserted into the tree

tree.c:
	No loop invariants
	
readWords.c:
	void getNextWord(char word[])
		//Precondition: at the end of the previous word
		for(;!(scroll>=(char)48 && scroll <= (char)57)&&!(scroll>=(c ...
		//loop invariant: char scroll is not a valid letter of a word
		//precondition: loop invariant: at the begining of the word to fill with the character
		 for(;(scroll>=(char)48 && scroll <= (char)57)||(scroll>=(char)65 && scroll..
		 //loop invariant:the next letter in the word is found and added to the word
		//loop invariant the word array is filled with the word.

Algorithm Explanation:

	Binary Tree:
	For the binary tree, we looked up online how it was possible to utilize a
	struct to create a binary tree. We mainly used sources 1 and 2 as well as
	the class slide on structs and binary trees. We developed the struct ourselves
	since that was very straight forward. The newNode() method was developed
	independently as well except for confirming some of the malloc'ing of 
	the word array with internet sources. We mainly used sources 1 and 2 in order
	to create the insert node function which alphabetically inserts a word or
	finds a word. We utilized the notes in order to confirm that strcmp() produced
	expected results. The insert function first compares the input word to word in
	the node, if the word is lower in the alphabet (closer to A) it will try and 
	perform the insert operation on the left tree or create a new node if the left
	node is NULL. The same operation is performed for the right side of the tree. 
	The function will recursively call itself until it either has to create a new 
	node or it finds that the word that is being compared is equal to the word 
	in the node that it is being compared to, this means count is incremented.
	
	The function that lists the tree, the words and their count,
	was developed independently. We only utilized the slides which taught "In-order"
	tree traversal. The algorithm is straightforward, the left side of the tree
	is accessed, if it exists, list tree is performed on it. Once all the left subtrees
	have been listed it will try to print the center node if it isn't NULL. Then it will
	list the right tree, again if it is not NULL. The function is called recusively in 
	the left and the right nodes.
	
	File Reading:
	The syntax for the file reading was obtained from source 6 below as well as the class
	slides. However most of the loops itself were developed independently. The giant
	for loop checks that the input word is not a punctuation character, otherwise it
	will continue looping and read the next character. The for loops decide when a 
	word starts as well as when it ends based on punctiation and spaces.
	
	
Test cases:
	TestCase1.txt:
		Contents:
		hello   ,s,..,, ..:trees

		binary?? !stuff
		
		Expected output:
		 Word:    |    Count: 
           binary |       1
            hello |       1
                s |       1
            stuff |       1
            trees |       1
	
		Total number of words: 5 
		Unique words: 5 
		
		Reasoning:
		The program should ignore all the unecessary punctuation found in this
		text file and output just the words included in the file and print
		it in alphabetical order. Also s is listed before stuff, because it 
		contains less letters than stuff, aside from being closer to the 
		start of the alphabet. The number of unique words and total words toward
		the end are also posted.
		
	TestCase2.txt:
		Contents:
		ss s aa s
		sda as ss
		sa sa ss
		ss as ss
		
		Expected Output:
		 Word:    |    Count: 
               aa |       1
               as |       2
                s |       2
               sa |       2
              sda |       1
               ss |       5

		Total number of words: 13 
		Unique words: 6 
		
		Reasoning:
		This test is provided to ensure that the logic behind the binary tree is correct
		as it is difficult to properly place many such similar words correctly in 
		the binary tree.
		
Sources:
1. http://www.geeksforgeeks.org/binary-tree-set-1-introduction/
2. http://cslibrary.stanford.edu/110/BinaryTrees.html
3. https://stackoverflow.com/questions/26874194/binary-tree-for-strings-c
4. http://publications.gbdirect.co.uk/c_book/chapter5/sizeof_and_malloc.html
5. https://stackoverflow.com/questions/7109964/creating-your-own-header-file-in-c
6. https://stackoverflow.com/questions/3463426/in-c-how-should-i-read-a-text-file-and-print-all-strings
